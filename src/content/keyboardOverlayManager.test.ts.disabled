import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { keyboardOverlayManager } from './keyboardOverlayManager'
import { Macro } from '../types'

// Mock React and ReactDOM
vi.mock('react', () => ({
  default: {
    createElement: vi.fn(() => ({}))
  },
  createElement: vi.fn(() => ({}))
}))

vi.mock('react-dom/client', () => ({
  default: {
    createRoot: vi.fn(() => ({
      render: vi.fn(),
      unmount: vi.fn()
    }))
  },
  createRoot: vi.fn(() => ({
    render: vi.fn(),
    unmount: vi.fn()
  }))
}))

// Mock the overlay components
vi.mock('./MacroSearchOverlay', () => ({
  MacroSearchOverlay: vi.fn(() => null)
}))

vi.mock('./MacroSuggestions', () => ({
  MacroSuggestions: vi.fn(() => null)
}))

// Mock editableUtils
vi.mock('./editableUtils', () => ({
  getActiveEditable: vi.fn(),
  getSelection: vi.fn(),
  replaceText: vi.fn()
}))

describe('KeyboardOverlayManager', () => {
  let testMacros: Macro[]
  let mockInput: HTMLInputElement
  let mockContentEditable: HTMLDivElement

  beforeEach(() => {
    // Clear DOM
    document.body.innerHTML = ''
    document.head.innerHTML = ''

    // Setup test macros
    testMacros = [
      {
        id: '1',
        command: '/test',
        text: 'Test macro content',
        contentType: 'text/plain'
      },
      {
        id: '2', 
        command: '/html',
        text: 'Rich content',
        html: '<strong>Rich content</strong>',
        contentType: 'text/html'
      }
    ]

    // Create test elements
    mockInput = document.createElement('input')
    mockInput.type = 'text'
    mockInput.id = 'test-input'
    document.body.appendChild(mockInput)

    mockContentEditable = document.createElement('div')
    mockContentEditable.contentEditable = 'true'
    mockContentEditable.id = 'test-contenteditable'
    mockContentEditable.innerHTML = '<p>Some <b>bold</b> text</p>'
    document.body.appendChild(mockContentEditable)

    // Update macros
    keyboardOverlayManager.updateMacros(testMacros)
  })

  afterEach(() => {
    keyboardOverlayManager.destroy()
    vi.clearAllMocks()
  })

  describe('Focus Management', () => {
    it('should store previously focused element when showing search overlay', () => {
      // Focus the input
      mockInput.focus()
      expect(document.activeElement).toBe(mockInput)

      // Show search overlay
      keyboardOverlayManager.showSearchOverlay()

      // The manager should have stored the focused element
      // We can't directly access private properties, but we can test the behavior
      expect(document.activeElement).toBe(mockInput)
    })

    it('should restore focus when hiding search overlay', async () => {
      const { getActiveEditable } = await import('./editableUtils')
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)

      // Focus input and show overlay
      mockInput.focus()
      keyboardOverlayManager.showSearchOverlay()
      
      // Hide overlay
      keyboardOverlayManager.hideSearchOverlay()

      // Focus should be restored after timeout
      await new Promise(resolve => setTimeout(resolve, 20))
      expect(document.activeElement).toBe(mockInput)
    })

    it('should handle focus restoration when element is removed from DOM', async () => {
      // Focus input and show overlay
      mockInput.focus()
      keyboardOverlayManager.showSearchOverlay()
      
      // Remove element from DOM
      document.body.removeChild(mockInput)
      
      // Hide overlay - should not throw error
      expect(() => {
        keyboardOverlayManager.hideSearchOverlay()
      }).not.toThrow()
    })
  })

  describe('Cursor Position Management', () => {
    it('should save cursor position when showing search overlay', async () => {
      const { getActiveEditable, getSelection } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)
      vi.mocked(getSelection).mockReturnValue({ start: 5, end: 5 })

      mockInput.focus()
      mockInput.setSelectionRange(5, 5)

      keyboardOverlayManager.showSearchOverlay()

      // Verify getSelection was called to save cursor position
      expect(getSelection).toHaveBeenCalledWith(mockInput)
    })

    it('should save cursor position in contenteditable elements', async () => {
      const { getActiveEditable, getSelection } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockContentEditable)
      vi.mocked(getSelection).mockReturnValue({ start: 3, end: 3 })

      mockContentEditable.focus()
      keyboardOverlayManager.showSearchOverlay()

      expect(getSelection).toHaveBeenCalledWith(mockContentEditable)
    })
  })

  describe('Macro Insertion', () => {
    it('should insert macro content at saved cursor position', async () => {
      const { getActiveEditable, getSelection, replaceText } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)
      vi.mocked(getSelection).mockReturnValue({ start: 5, end: 5 })

      // Setup scenario: focus input, show overlay, select macro
      mockInput.focus()
      keyboardOverlayManager.showSearchOverlay()
      
      // Simulate macro selection
      keyboardOverlayManager.handleMacroSelection(testMacros[0])

      // Verify replaceText was called with correct parameters
      expect(replaceText).toHaveBeenCalledWith(
        mockInput,
        testMacros[0],
        5, // start position
        5  // end position (same as start for insertion)
      )
    })

    it('should handle HTML macro insertion in contenteditable', async () => {
      const { getActiveEditable, getSelection, replaceText } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockContentEditable)
      vi.mocked(getSelection).mockReturnValue({ start: 3, end: 3 })

      mockContentEditable.focus()
      keyboardOverlayManager.showSearchOverlay()
      
      // Select HTML macro
      keyboardOverlayManager.handleMacroSelection(testMacros[1])

      expect(replaceText).toHaveBeenCalledWith(
        mockContentEditable,
        testMacros[1],
        3,
        3
      )
    })

    it('should clear saved cursor position after insertion', async () => {
      const { getActiveEditable, getSelection } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)
      vi.mocked(getSelection).mockReturnValue({ start: 5, end: 5 })

      mockInput.focus()
      keyboardOverlayManager.showSearchOverlay()
      keyboardOverlayManager.handleMacroSelection(testMacros[0])

      // Show overlay again - should get fresh cursor position
      keyboardOverlayManager.showSearchOverlay()
      expect(getSelection).toHaveBeenCalledTimes(2)
    })

    it('should handle insertion when no saved cursor position exists', async () => {
      const { getActiveEditable, getSelection, replaceText } = await import('./editableUtils')
      
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)
      vi.mocked(getSelection).mockReturnValue({ start: 0, end: 0 })

      // Don't show overlay first (no saved position)
      keyboardOverlayManager.handleMacroSelection(testMacros[0])

      // Should get current cursor position and use it
      expect(getSelection).toHaveBeenCalledWith(mockInput)
      expect(replaceText).toHaveBeenCalledWith(mockInput, testMacros[0], 0, 0)
    })
  })

  describe('Suggestions Management', () => {
    it('should preserve focus tracking when showing suggestions', async () => {
      const { getActiveEditable } = await import('./editableUtils')
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)

      mockInput.focus()
      
      // Show suggestions - should track focus but not override if already tracked
      keyboardOverlayManager.showSuggestions('test', 0, 0)
      keyboardOverlayManager.showSearchOverlay() // This should not override
      
      keyboardOverlayManager.handleMacroSelection(testMacros[0])
      
      // Focus should be restored to original input
      await new Promise(resolve => setTimeout(resolve, 20))
      expect(document.activeElement).toBe(mockInput)
    })

    it('should handle suggestions hiding without affecting search overlay focus', () => {
      mockInput.focus()
      
      keyboardOverlayManager.showSearchOverlay()
      keyboardOverlayManager.showSuggestions('test', 0, 0)
      
      // Hide suggestions while search is visible
      keyboardOverlayManager.hideSuggestions()
      
      // Should not restore focus yet (search overlay still visible)
      expect(document.activeElement).toBe(mockInput)
    })
  })

  describe('Error Handling', () => {
    it('should handle macro insertion with invalid target element', async () => {
      const { getActiveEditable } = await import('./editableUtils')
      vi.mocked(getActiveEditable).mockReturnValue(null)

      expect(() => {
        keyboardOverlayManager.handleMacroSelection(testMacros[0])
      }).not.toThrow()
    })

    it('should handle macro insertion with empty macro text', async () => {
      const { getActiveEditable } = await import('./editableUtils')
      vi.mocked(getActiveEditable).mockReturnValue(mockInput)

      const emptyMacro: Macro = {
        id: 'empty',
        command: '/empty',
        text: '',
        contentType: 'text/plain'
      }

      expect(() => {
        keyboardOverlayManager.handleMacroSelection(emptyMacro)
      }).not.toThrow()
    })

    it('should handle focus restoration when document does not contain element', async () => {
      mockInput.focus()
      keyboardOverlayManager.showSearchOverlay()
      
      // Simulate element being removed
      Object.defineProperty(document.body, 'contains', {
        value: vi.fn().mockReturnValue(false)
      })
      
      expect(() => {
        keyboardOverlayManager.hideSearchOverlay()
      }).not.toThrow()
    })
  })

  describe('Event Dispatching', () => {
    it('should dispatch macro-selected event with correct details', () => {
      const eventSpy = vi.spyOn(document, 'dispatchEvent')
      
      keyboardOverlayManager.updatePosition(100, 200)
      keyboardOverlayManager.handleMacroSelection(testMacros[0])

      expect(eventSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'macro-selected',
          detail: {
            macro: testMacros[0],
            position: { x: 100, y: 200 }
          }
        })
      )
    })
  })

  describe('CSS Injection', () => {
    it('should inject overlay styles only once', () => {
      // Create manager (styles should be injected)
      const manager1 = keyboardOverlayManager
      
      // Check styles exist
      const styleElement = document.getElementById('macro-overlay-styles')
      expect(styleElement).toBeTruthy()
      expect(styleElement?.tagName).toBe('STYLE')
      
      // Create another manager - should not duplicate styles
      const existingStyles = document.querySelectorAll('#macro-overlay-styles')
      expect(existingStyles.length).toBe(1)
    })

    it('should clean up styles on destroy', () => {
      keyboardOverlayManager.destroy()
      
      const styleElement = document.getElementById('macro-overlay-styles')
      expect(styleElement).toBeFalsy()
    })
  })
})