[1mdiff --git a/docs/TODO.md b/docs/TODO.md[m
[1mindex b5bf5c5..c046c49 100644[m
[1m--- a/docs/TODO.md[m
[1m+++ b/docs/TODO.md[m
[36m@@ -18,8 +18,10 @@[m
 [ ] Unify all the interface popup and editor into the overlay modal currently used only to search. So they are going to be new views accessible by two buttons: create/edit macros and options.[m
 [ ] In the search modal it should be little label indicating the current number of macros in the results.[m
 [ ] The undo should be able to delete an immediately replaced macro. That should be the undo behavior after a macro commit.[m
[31m-[ ] FIX: I found an issue in while working with the tests: the space is not triggering a macro if there is another macro that starts with the same prefix.[m
[31m-[ ] FIX: The undo test are currently made to be used with commit keys but currently the detector is working in auto mode.[m
[32m+[m[32m[ ] Fix: I found an issue in while working with the tests: the space is not triggering a macro if there is another macro that starts with the same prefix.[m
[32m+[m[32m[x] Fix: The undo test are currently made to be used with commit keys but currently the detector is working in auto mode.[m
[32m+[m[32m[ ] Fix: in auto mode the undo does not get cleared and repeats the command after the previous undo.[m
[32m+[m[32m[ ] Search overlay is not restoring focus not managing undo.[m
 [m
 [m
 [m
[36m@@ -32,4 +34,11 @@[m
 [ ] The navigation help at the bottom should be showing only when the ? key is pressed or by adding a ? button at the end of the macro suggestions, and therefore showing the content of the navigation instructions in the same place that the suggestions text appears for the other suggestions buttons.[m
 [ ] Fix: The window bottom space is not being calculated properly, or is not moving the popup accordingly.[m
 [ ] Fix: The suggestions buttons are not triggering the replacement when clicked.[m
[32m+[m[32m[ ] Fix: After the suggestions replacement the undo is not working.[m
[32m+[m[32m[ ] Fix: Replacement is not happening when manual mode is on.[m
[32m+[m
[32m+[m
[32m+[m[32m### Search[m
[32m+[m
[32m+[m[32m[ ] Fix: The search is no bringing the focus back.[m
 [m
[1mdiff --git a/src/content/detector/editableUtils.ts b/src/content/detector/editableUtils.ts[m
[1mindex 51b0085..23967e0 100644[m
[1m--- a/src/content/detector/editableUtils.ts[m
[1m+++ b/src/content/detector/editableUtils.ts[m
[36m@@ -5,28 +5,42 @@[m [mexport function getActiveEditable(target: EventTarget | null): EditableEl {[m
     if (target.type === "password") return null[m
     return target[m
   }[m
[31m-  [m
[32m+[m
   // For contenteditable elements, we need to traverse up the DOM tree[m
   // because the target might be a child element (text node, <b>, <i>, etc.)[m
   let element: HTMLElement | null = null;[m
[31m-  [m
[32m+[m
   if (target instanceof HTMLElement) {[m
     element = target;[m
   } else if (target instanceof Node && target.parentElement) {[m
     // Handle text nodes and other non-HTMLElement nodes[m
     element = target.parentElement;[m
   }[m
[31m-  [m
[32m+[m
   while (element) {[m
     if (element.isContentEditable || element.contentEditable === "true") {[m
       return element;[m
     }[m
     element = element.parentElement;[m
   }[m
[31m-  [m
[32m+[m
   return null[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Extract text content from an editable element[m
[32m+[m[32m */[m
[32m+[m[32mexport function getTextContent(element: EditableEl): string {[m
[32m+[m[32m  if (!element) return ''[m
[32m+[m
[32m+[m[32m  if ('value' in element) {[m
[32m+[m[32m    return element.value[m
[32m+[m[32m  } else if ('textContent' in element) {[m
[32m+[m[32m    return element.textContent || ''[m
[32m+[m[32m  }[m
[32m+[m[32m  return ''[m
[32m+[m[32m}[m
[32m+[m
 /**[m
  * Given a root node and a character offset, finds the text node and offset within[m
  * that text node that corresponds to the character offset.[m
[1mdiff --git a/src/content/detector/macroCore.ts b/src/content/detector/macroCore.ts[m
[1mindex 249686d..e787ad5 100644[m
[1m--- a/src/content/detector/macroCore.ts[m
[1m+++ b/src/content/detector/macroCore.ts[m
[36m@@ -59,6 +59,13 @@[m [mexport function createMacroCore(actions: DetectorActions) {[m
     detector.handleMacroSelectedFromOverlay(macro, buffer, element)[m
   }[m
 [m
[32m+[m[32m  /**[m
[32m+[m[32m   * Handle macro selection from search overlay[m
[32m+[m[32m   */[m
[32m+[m[32m  function handleMacroSelectedFromSearchOverlay(macro: Macro, element: EditableEl): void {[m
[32m+[m[32m    detector.handleMacroSelectedFromSearchOverlay(macro, element)[m
[32m+[m[32m  }[m
[32m+[m
   /**[m
    * Destroy the macro system and clean up[m
    */[m
[36m@@ -74,6 +81,7 @@[m [mexport function createMacroCore(actions: DetectorActions) {[m
     clearUndoHistory,[m
     getUndoHistoryLength,[m
     handleMacroSelectedFromOverlay,[m
[32m+[m[32m    handleMacroSelectedFromSearchOverlay,[m
     destroy,[m
   }[m
 }[m
[1mdiff --git a/src/content/detector/macroDetector.test.ts b/src/content/detector/macroDetector.test.ts[m
[1mindex 8d293ed..d930470 100644[m
[1m--- a/src/content/detector/macroDetector.test.ts[m
[1m+++ b/src/content/detector/macroDetector.test.ts[m
[36m@@ -26,6 +26,7 @@[m [mvi.mock('./editableUtils', () => ({[m
   getSelection: vi.fn(),[m
   replaceText: vi.fn(),[m
   getCursorCoordinates: vi.fn(),[m
[32m+[m[32m  getTextContent: vi.fn(),[m
 }))[m
 [m
 vi.mock('../keyUtils', () => ({[m
[1mdiff --git a/src/content/detector/macroDetector.ts b/src/content/detector/macroDetector.ts[m
[1mindex 4647333..9c06d82 100644[m
[1m--- a/src/content/detector/macroDetector.ts[m
[1m+++ b/src/content/detector/macroDetector.ts[m
[36m@@ -448,6 +448,30 @@[m [mexport function createMacroDetector(actions: DetectorActions) {[m
     cancelDetection()[m
   }[m
 [m
[32m+[m[32m  /**[m
[32m+[m[32m   * Handle macro selection from search overlay (inserts at cursor position)[m
[32m+[m[32m   */[m
[32m+[m[32m  function handleMacroSelectedFromSearchOverlay(macro: Macro, element: EditableEl): void {[m
[32m+[m[32m    if (!element) {[m
[32m+[m[32m      return[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Restore focus to the element first[m
[32m+[m[32m    element.focus()[m
[32m+[m
[32m+[m[32m    const cursorPos = replacement.getCursorPosition(element)[m
[32m+[m
[32m+[m[32m    if (cursorPos === null) {[m
[32m+[m[32m      return[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Insert at current cursor position (no text to replace)[m
[32m+[m[32m    // Use performReplacement to ensure proper undo tracking[m
[32m+[m[32m    replacement.performReplacement(element, cursorPos, cursorPos, macro.text, macro)[m
[32m+[m
[32m+[m[32m    actions.onMacroCommitted(String(macro.id))[m
[32m+[m[32m  }[m
[32m+[m
   return {[m
     initialize,[m
     setMacros,[m
[36m@@ -459,6 +483,7 @@[m [mexport function createMacroDetector(actions: DetectorActions) {[m
     getUndoHistoryLength: () => replacement.getUndoHistoryLength(),[m
     // Expose for overlay integration[m
     handleMacroSelectedFromOverlay,[m
[32m+[m[32m    handleMacroSelectedFromSearchOverlay,[m
   }[m
 }[m
 [m
[1mdiff --git a/src/content/detector/macroReplacement.ts b/src/content/detector/macroReplacement.ts[m
[1mindex cd70715..423306a 100644[m
[1m--- a/src/content/detector/macroReplacement.ts[m
[1m+++ b/src/content/detector/macroReplacement.ts[m
[36m@@ -1,212 +1,17 @@[m
 import { Macro, EditableEl } from "../../types"[m
[31m-[m
[31m-// Types for element references and history[m
[31m-export interface ElementRef {[m
[31m-  id?: string;[m
[31m-  selector?: string;[m
[31m-  element: EditableEl;[m
[31m-}[m
[31m-[m
[31m-export interface ReplacementHistoryEntry {[m
[31m-  elementRef: ElementRef;[m
[31m-  startPos: number[m
[31m-  endPos: number[m
[31m-  originalText: string[m
[31m-  replacementText: string[m
[31m-  macro: Macro[m
[31m-  timestamp: number[m
[31m-  elementId: string[m
[31m-}[m
[31m-[m
[31m-const MAX_UNDO_HISTORY = 50 // Keep last 50 replacements[m
[32m+[m[32mimport { getTextContent, getSelection, replaceText } from "./editableUtils"[m
[32m+[m[32mimport { createReplacementHistory } from "./replacementHistory"[m
 [m
 /**[m
[31m- * Creates a macro replacement manager that handles text replacements and undo operations[m
[32m+[m[32m * Creates a macro replacement manager that handles text replacements and undo operations.[m
[32m+[m[32m * Uses a position-based undo system that captures text positions and snippets.[m
  */[m
 export function createMacroReplacement() {[m
[31m-  // Undo history stack[m
[31m-  const undoHistory: ReplacementHistoryEntry[] = [][m
[31m-[m
[31m-  // Map to track element IDs for efficient lookup[m
[31m-  const elementIdMap = new WeakMap<EditableEl, string>()[m
[31m-  let elementCounter = 0[m
[31m-[m
[31m-  /**[m
[31m-   * Generate or get unique ID for element[m
[31m-   */[m
[31m-  function getElementId(element: EditableEl): string {[m
[31m-    if (!elementIdMap.has(element)) {[m
[31m-      const id = `element_${elementCounter++}`[m
[31m-      elementIdMap.set(element, id)[m
[31m-    }[m
[31m-    return elementIdMap.get(element)![m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Extract text content from an editable element[m
[31m-   */[m
[31m-  function getTextContent(element: EditableEl): string {[m
[31m-    if (!element) return ''[m
[31m-[m
[31m-    if ('value' in element) {[m
[31m-      return element.value[m
[31m-    } else if ('textContent' in element) {[m
[31m-      return element.textContent || ''[m
[31m-    }[m
[31m-    return ''[m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Get current cursor position in the element[m
[31m-   */[m
[31m-  function getCursorPosition(element: EditableEl): number | null {[m
[31m-    if (!element) return null[m
[31m-[m
[31m-    if ('selectionStart' in element) {[m
[31m-      return element.selectionStart[m
[31m-    } else if (element.isContentEditable) {[m
[31m-      const selection = window.getSelection()[m
[31m-      if (!selection || selection.rangeCount === 0) return null[m
[31m-[m
[31m-      const range = selection.getRangeAt(0)[m
[31m-      const preCaretRange = range.cloneRange()[m
[31m-      preCaretRange.selectNodeContents(element as Node)[m
[31m-      preCaretRange.setEnd(range.endContainer, range.endOffset)[m
[31m-      return preCaretRange.toString().length[m
[31m-    }[m
[31m-[m
[31m-    return null[m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Set cursor position in the element[m
[31m-   */[m
[31m-  function setCursorPosition(element: EditableEl, position: number): void {[m
[31m-    if (!element) return[m
[31m-[m
[31m-    if ('setSelectionRange' in element) {[m
[31m-      element.focus()[m
[31m-      element.setSelectionRange(position, position)[m
[31m-    } else if (element.isContentEditable) {[m
[31m-      const selection = window.getSelection()[m
[31m-      if (!selection) return[m
[31m-[m
[31m-      let currentPos = 0[m
[31m-      const walker = document.createTreeWalker([m
[31m-        element as Node,[m
[31m-        NodeFilter.SHOW_TEXT,[m
[31m-        null[m
[31m-      )[m
[31m-[m
[31m-      let node: Text | null = null[m
[31m-      while ((node = walker.nextNode() as Text)) {[m
[31m-        const nodeLength = node.textContent?.length || 0[m
[31m-[m
[31m-        if (currentPos + nodeLength >= position) {[m
[31m-          const range = document.createRange()[m
[31m-          range.setStart(node, position - currentPos)[m
[31m-          range.collapse(true)[m
[31m-          selection.removeAllRanges()[m
[31m-          selection.addRange(range)[m
[31m-          return[m
[31m-        }[m
[31m-[m
[31m-        currentPos += nodeLength[m
[31m-      }[m
[31m-    }[m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Create a Range object from text positions in a contentEditable element[m
[31m-   */[m
[31m-  function createRangeFromTextPositions([m
[31m-    element: EditableEl,[m
[31m-    startPos: number,[m
[31m-    endPos: number[m
[31m-  ): Range | null {[m
[31m-    if (!element) return null[m
[31m-[m
[31m-    const range = document.createRange()[m
[31m-    let currentPos = 0[m
[31m-    let startNode: Node | null = null[m
[31m-    let startOffset = 0[m
[31m-    let endNode: Node | null = null[m
[31m-    let endOffset = 0[m
[31m-[m
[31m-    const walker = document.createTreeWalker([m
[31m-      element as Node,[m
[31m-      NodeFilter.SHOW_TEXT,[m
[31m-      null[m
[31m-    )[m
[31m-[m
[31m-    let node: Text | null = null[m
[31m-    while ((node = walker.nextNode() as Text)) {[m
[31m-      const nodeLength = node.textContent?.length || 0[m
[31m-[m
[31m-      // Find start position[m
[31m-      if (!startNode && currentPos + nodeLength >= startPos) {[m
[31m-        startNode = node[m
[31m-        startOffset = startPos - currentPos[m
[31m-      }[m
[31m-[m
[31m-      // Find end position[m
[31m-      if (!endNode && currentPos + nodeLength >= endPos) {[m
[31m-        endNode = node[m
[31m-        endOffset = endPos - currentPos[m
[31m-        break[m
[31m-      }[m
[31m-[m
[31m-      currentPos += nodeLength[m
[31m-    }[m
[31m-[m
[31m-    if (!startNode || !endNode) return null[m
[31m-[m
[31m-    try {[m
[31m-      range.setStart(startNode, startOffset)[m
[31m-      range.setEnd(endNode, endOffset)[m
[31m-      return range[m
[31m-    } catch (error) {[m
[31m-      console.error('Error creating range:', error)[m
[31m-      return null[m
[31m-    }[m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Replace text in contentEditable while preserving HTML formatting[m
[31m-   */[m
[31m-  function replaceInContentEditablePreservingFormat([m
[31m-    element: EditableEl,[m
[31m-    startPos: number,[m
[31m-    endPos: number,[m
[31m-    replacementText: string[m
[31m-  ): void {[m
[31m-    const selection = window.getSelection()[m
[31m-    if (!selection) return[m
[31m-[m
[31m-    // Find the text node(s) that contain our target range[m
[31m-    const range = createRangeFromTextPositions(element, startPos, endPos)[m
[31m-    if (!range) return[m
[31m-[m
[31m-    // Select the range[m
[31m-    selection.removeAllRanges()[m
[31m-    selection.addRange(range)[m
[31m-[m
[31m-    // Delete the selected content[m
[31m-    range.deleteContents()[m
[31m-[m
[31m-    // Insert the replacement text as a text node[m
[31m-    const textNode = document.createTextNode(replacementText)[m
[31m-    range.insertNode(textNode)[m
[31m-[m
[31m-    // Move cursor after the inserted text[m
[31m-    range.setStartAfter(textNode)[m
[31m-    range.collapse(true)[m
[31m-    selection.removeAllRanges()[m
[31m-    selection.addRange(range)[m
[31m-  }[m
[32m+[m[32m  // Create history manager[m
[32m+[m[32m  const history = createReplacementHistory()[m
 [m
   /**[m
[31m-   * Perform text replacement and track in history[m
[32m+[m[32m   * Perform text replacement and track in history for undo[m
    */[m
   function performReplacement([m
     element: EditableEl,[m
[36m@@ -216,12 +21,11 @@[m [mexport function createMacroReplacement() {[m
     macro: Macro,[m
     undoStartPos?: number,[m
     undoEndPos?: number,[m
[31m-    originalMacroCommand?: string  // The original macro command for immediate mode[m
[32m+[m[32m    originalMacroCommand?: string[m
   ): void {[m
     if (!element) return[m
 [m
     const textContent = getTextContent(element)[m
[31m-    const originalText = textContent.substring(startPos, endPos)[m
 [m
     // For undo, use the original range (before space adjustment) if provided[m
     // In immediate mode, we may have a specific original command to restore[m
[36m@@ -231,7 +35,7 @@[m [mexport function createMacroReplacement() {[m
       originalText: originalMacroCommand ||[m
                    (undoStartPos !== undefined && undoEndPos !== undefined[m
                      ? textContent.substring(undoStartPos, undoEndPos)[m
[31m-                     : originalText)[m
[32m+[m[32m                     : textContent.substring(startPos, endPos))[m
     }[m
 [m
     // Debug: Uncomment for undo history debugging[m
[36m@@ -241,210 +45,81 @@[m [mexport function createMacroReplacement() {[m
     //   originalText: JSON.stringify(undoRange.originalText),[m
     //   replacementText: JSON.stringify(replacementText),[m
     //   actualReplacementRange: { startPos, endPos },[m
[31m-    //   actualReplacementText: JSON.stringify(originalText)[m
[32m+[m[32m    //   actualReplacementText: JSON.stringify(textContent.substring(startPos, endPos))[m
     // })[m
 [m
     // Store in undo history using the original range[m
[31m-    const elementId = getElementId(element);[m
[31m-    const historyEntry: ReplacementHistoryEntry = {[m
[31m-      elementRef: { element, id: elementId },[m
[31m-      startPos: undoRange.startPos,[m
[31m-      endPos: undoRange.endPos,[m
[31m-      originalText: undoRange.originalText,[m
[31m-      replacementText,[m
[31m-      macro,[m
[31m-      timestamp: Date.now(),[m
[31m-      elementId[m
[31m-    }[m
[31m-[m
[31m-    undoHistory.push(historyEntry)[m
[31m-[m
[31m-    // Keep history size manageable[m
[31m-    if (undoHistory.length > MAX_UNDO_HISTORY) {[m
[31m-      undoHistory.shift()[m
[31m-    }[m
[31m-[m
[31m-    // Perform the actual replacement[m
[31m-    if ('value' in element) {[m
[31m-      // Input/textarea[m
[31m-      const newValue = textContent.substring(0, startPos) + replacementText + textContent.substring(endPos)[m
[31m-      element.value = newValue[m
[31m-[m
[31m-      // Set cursor after replacement[m
[31m-      const newCursorPos = startPos + replacementText.length[m
[31m-      element.setSelectionRange(newCursorPos, newCursorPos)[m
[31m-[m
[31m-      // Dispatch input event for framework reactivity[m
[31m-      element.dispatchEvent(new Event('input', { bubbles: true }))[m
[31m-    } else if (element.isContentEditable || element.contentEditable === 'true') {[m
[31m-      // ContentEditable - use Selection API to preserve formatting[m
[31m-      replaceInContentEditablePreservingFormat(element, startPos, endPos, replacementText)[m
[32m+[m[32m    history.createEntry([m
[32m+[m[32m      element,[m
[32m+[m[32m      undoRange.startPos,[m
[32m+[m[32m      undoRange.endPos,[m
[32m+[m[32m      undoRange.originalText,[m
[32m+[m[32m      replacementText[m
[32m+[m[32m    )[m
 [m
[31m-      // Dispatch input event[m
[31m-      element.dispatchEvent(new Event('input', { bubbles: true }))[m
[32m+[m[32m    // Perform the actual replacement using tested editableUtils[m
[32m+[m[32m    const macroForReplacement: Macro = {[m
[32m+[m[32m      ...macro,[m
[32m+[m[32m      text: replacementText[m
     }[m
[31m-  }[m
[31m-[m
[31m-  /**[m
[31m-   * Undo replacement in contentEditable while preserving HTML formatting[m
[31m-   */[m
[31m-  function undoInContentEditablePreservingFormat([m
[31m-    element: EditableEl,[m
[31m-    startPos: number,[m
[31m-    endPos: number,[m
[31m-    originalText: string[m
[31m-  ): void {[m
[31m-    const selection = window.getSelection()[m
[31m-    if (!selection) return[m
[31m-[m
[31m-    // Find and select the replacement text[m
[31m-    const range = createRangeFromTextPositions(element, startPos, endPos)[m
[31m-    if (!range) return[m
[31m-[m
[31m-    selection.removeAllRanges()[m
[31m-    selection.addRange(range)[m
[31m-[m
[31m-    // Delete the replacement[m
[31m-    range.deleteContents()[m
[31m-[m
[31m-    // Insert the original text[m
[31m-    const textNode = document.createTextNode(originalText)[m
[31m-    range.insertNode(textNode)[m
[31m-[m
[31m-    // Move cursor after the restored text[m
[31m-    range.setStartAfter(textNode)[m
[31m-    range.collapse(true)[m
[31m-    selection.removeAllRanges()[m
[31m-    selection.addRange(range)[m
[32m+[m[32m    replaceText(element, macroForReplacement, startPos, endPos)[m
   }[m
 [m
   /**[m
    * Undo the last macro replacement for a specific element[m
    */[m
   function undoLastReplacement(activeEl: EditableEl): boolean {[m
[31m-    if (undoHistory.length === 0 || !activeEl) return false[m
[31m-[m
[31m-    const activeElementId = getElementId(activeEl);[m
[31m-[m
[31m-    // Find the index of the last entry for the active element[m
[31m-    let lastEntryIndex = -1[m
[31m-    for (let i = undoHistory.length - 1; i >= 0; i--) {[m
[31m-      if (undoHistory[i].elementId === activeElementId) {[m
[31m-        lastEntryIndex = i[m
[31m-        break[m
[31m-      }[m
[31m-    }[m
[31m-[m
[31m-    if (lastEntryIndex === -1) return false[m
[31m-[m
[31m-    const lastEntry = undoHistory.splice(lastEntryIndex, 1)[0][m
[31m-    if (!lastEntry) return false[m
[31m-[m
[31m-    const { elementRef, startPos, originalText, replacementText } = lastEntry;[m
[31m-    const element = elementRef.element;[m
[31m-[m
[31m-    // Check if element still exists and is valid[m
[31m-    if (!element || !document.contains(element as Node)) {[m
[31m-      return false[m
[31m-    }[m
[31m-[m
[31m-    const currentContent = getTextContent(element)[m
[31m-    const currentCursorPos = getCursorPosition(element)[m
[31m-[m
[31m-    // Calculate where the replacement should be in current content[m
[31m-    const expectedReplacementPos = startPos[m
[31m-    const expectedEndPos = startPos + replacementText.length[m
[31m-[m
[31m-    // Verify the replacement text is still there[m
[31m-    const actualText = currentContent.substring(expectedReplacementPos, expectedEndPos)[m
[31m-[m
[31m-    // Debug: Uncomment for undo restoration debugging[m
[31m-    // console.log('[UNDO] Restoration debug:', {[m
[31m-    //   currentContent: JSON.stringify(currentContent),[m
[31m-    //   startPos, expectedReplacementPos, expectedEndPos,[m
[31m-    //   replacementText: JSON.stringify(replacementText),[m
[31m-    //   actualText: JSON.stringify(actualText),[m
[31m-    //   originalText: JSON.stringify(originalText),[m
[31m-    //   matches: actualText === replacementText[m
[31m-    // })[m
[31m-[m
[31m-    if (actualText === replacementText) {[m
[31m-      // Simple case: replacement is still in original position[m
[31m-      if ('value' in element) {[m
[31m-        const before = currentContent.substring(0, expectedReplacementPos)[m
[31m-        const after = currentContent.substring(expectedEndPos)[m
[31m-        const newValue = before + originalText + after[m
[31m-[m
[31m-        element.value = newValue[m
[31m-[m
[31m-        // Set cursor at end of restored text[m
[31m-        element.setSelectionRange(startPos + originalText.length, startPos + originalText.length)[m
[31m-        element.dispatchEvent(new Event('input', { bubbles: true }))[m
[31m-      } else if (element.isContentEditable || (element as any).contentEditable === 'true') {[m
[31m-        // Use Selection API to preserve formatting[m
[31m-        undoInContentEditablePreservingFormat(element, expectedReplacementPos, expectedEndPos, originalText)[m
[31m-        element.dispatchEvent(new Event('input', { bubbles: true }))[m
[31m-      }[m
[31m-      return true[m
[31m-    } else {[m
[31m-      // Complex case: try to find the replacement text elsewhere[m
[31m-      const replacementIndex = currentContent.indexOf(replacementText, Math.max(0, startPos - 10))[m
[31m-[m
[31m-      if (replacementIndex !== -1) {[m
[31m-        const endIndex = replacementIndex + replacementText.length[m
[31m-[m
[31m-        if ('value' in element) {[m
[31m-          const newValue = currentContent.substring(0, replacementIndex) +[m
[31m-                          originalText +[m
[31m-                          currentContent.substring(endIndex)[m
[31m-          element.value = newValue[m
[31m-          element.setSelectionRange(replacementIndex + originalText.length, replacementIndex + originalText.length)[m
[31m-          element.dispatchEvent(new Event('input', { bubbles: true }))[m
[31m-        } else if (element.isContentEditable) {[m
[31m-          undoInContentEditablePreservingFormat(element, replacementIndex, endIndex, originalText)[m
[31m-          element.dispatchEvent(new Event('input', { bubbles: true }))[m
[31m-        }[m
[31m-        return true[m
[31m-      }[m
[31m-    }[m
[31m-[m
[31m-    return false[m
[32m+[m[32m    return history.undo(activeEl)[m
   }[m
 [m
   /**[m
    * Clear undo history for a specific element or all[m
    */[m
   function clearUndoHistory(element?: EditableEl): void {[m
[31m-    if (element) {[m
[31m-      const elementId = getElementId(element);[m
[31m-      // Remove entries for specific element[m
[31m-      for (let i = undoHistory.length - 1; i >= 0; i--) {[m
[31m-        if (undoHistory[i].elementId === elementId) {[m
[31m-          undoHistory.splice(i, 1)[m
[31m-        }[m
[31m-      }[m
[31m-    } else {[m
[31m-      // Clear all history[m
[31m-      undoHistory.length = 0[m
[31m-    }[m
[32m+[m[32m    history.clear(element)[m
   }[m
 [m
   /**[m
    * Check if there is undo history for a specific element[m
    */[m
   function hasUndoHistory(element: EditableEl): boolean {[m
[31m-    if (!element) return false[m
[31m-    const elementId = getElementId(element)[m
[31m-    return undoHistory.some(entry => entry.elementId === elementId)[m
[32m+[m[32m    return history.hasHistory(element)[m
   }[m
 [m
   /**[m
    * Get the number of undo history entries[m
    */[m
   function getUndoHistoryLength(): number {[m
[31m-    return undoHistory.length[m
[32m+[m[32m    return history.getHistoryLength()[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * Get element ID (for debugging/testing)[m
[32m+[m[32m   */[m
[32m+[m[32m  function getElementId(element: EditableEl): string {[m
[32m+[m[32m    return history.getElementId(element)[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * Get current cursor position (for backward compatibility)[m
[32m+[m[32m   */[m
[32m+[m[32m  function getCursorPosition(element: EditableEl): number | null {[m
[32m+[m[32m    return getSelection(element)?.start ?? null[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * Set cursor position (for backward compatibility)[m
[32m+[m[32m   * This is a simplified version - full implementation is in editableUtils[m
[32m+[m[32m   */[m
[32m+[m[32m  function setCursorPosition(element: EditableEl, position: number): void {[m
[32m+[m[32m    if ('setSelectionRange' in element) {[m
[32m+[m[32m      element.focus()[m
[32m+[m[32m      element.setSelectionRange(position, position)[m
[32m+[m[32m    }[m
[32m+[m[32m    // For contentEditable, this would need more complex logic from editableUtils[m
   }[m
 [m
[32m+[m[32m  // Re-export utilities for backward compatibility[m
   return {[m
     performReplacement,[m
     undoLastReplacement,[m
[36m@@ -454,7 +129,7 @@[m [mexport function createMacroReplacement() {[m
     getElementId,[m
     getTextContent,[m
     getCursorPosition,[m
[31m-    setCursorPosition,[m
[32m+[m[32m    setCursorPosition[m
   }[m
 }[m
 [m
[1mdiff --git a/src/content/main.test.ts b/src/content/main.test.ts[m
[1mindex 1dcf6ab..4daab1e 100644[m
[1m--- a/src/content/main.test.ts[m
[1m+++ b/src/content/main.test.ts[m
[36m@@ -25,7 +25,13 @@[m [mconst mockOverlays = vi.hoisted(() => ({[m
     destroy: vi.fn(),[m
     setOnMacroSelected: vi.fn(),[m
   },[m
[31m-  searchOverlayManager: {},[m
[32m+[m[32m  searchOverlayManager: {[m
[32m+[m[32m    show: vi.fn(),[m
[32m+[m[32m    hide: vi.fn(),[m
[32m+[m[32m    isVisible: vi.fn(() => false),[m
[32m+[m[32m    destroy: vi.fn(),[m
[32m+[m[32m    setOnMacroSelected: vi.fn(),[m
[32m+[m[32m  },[m
   updateAllMacros: vi.fn(),[m
 }))[m
 [m
[1mdiff --git a/src/content/main.ts b/src/content/main.ts[m
[1mindex 5017e16..7d2fe71 100644[m
[1m--- a/src/content/main.ts[m
[1m+++ b/src/content/main.ts[m
[36m@@ -2,7 +2,7 @@[m [mimport { useMacroStore } from "../store/useMacroStore"[m
 import { createMacroCore, MacroCore } from "./detector/macroCore"[m
 import { createSuggestionsCoordinator, SuggestionsCoordinator } from "./coordinators/SuggestionsCoordinator"[m
 import { loadMacros, listenMacrosChange } from "./storage/macroStorage"[m
[31m-import { updateAllMacros, suggestionsOverlayManager } from "./overlays"[m
[32m+[m[32mimport { updateAllMacros, suggestionsOverlayManager, searchOverlayManager } from "./overlays"[m
 import { Macro } from "../types"[m
 [m
 // Module-level state[m
[36m@@ -71,13 +71,20 @@[m [mfunction manageMacroState() {[m
       macroCore = createAndInitializeMacroCore(suggestionsCoordinator)[m
       isDetectorActive = true[m
 [m
[31m-      // Wire the overlay manager to use macro core's replacement function for proper undo tracking[m
[32m+[m[32m      // Wire the suggestions overlay manager to use macro core's replacement function for proper undo tracking[m
       overlayManager.setOnMacroSelected((macro, buffer, element) => {[m
         if (macroCore) {[m
           macroCore.handleMacroSelectedFromOverlay(macro, buffer, element)[m
         }[m
       })[m
 [m
[32m+[m[32m      // Wire the search overlay manager to use macro core's insertion function for proper undo tracking[m
[32m+[m[32m      searchOverlayManager.setOnMacroSelected((macro, element) => {[m
[32m+[m[32m        if (macroCore) {[m
[32m+[m[32m          macroCore.handleMacroSelectedFromSearchOverlay(macro, element)[m
[32m+[m[32m        }[m
[32m+[m[32m      })[m
[32m+[m
       // Set macros if we have them[m
       const macros = useMacroStore.getState().macros[m
       if (macros.length > 0) {[m
[1mdiff --git a/src/content/overlays/searchOverlay/searchOverlayManager.ts b/src/content/overlays/searchOverlay/searchOverlayManager.ts[m
[1mindex 073c7da..76aaa97 100644[m
[1m--- a/src/content/overlays/searchOverlay/searchOverlayManager.ts[m
[1m+++ b/src/content/overlays/searchOverlay/searchOverlayManager.ts[m
[36m@@ -1,25 +1,44 @@[m
 import React from 'react';[m
[31m-import { Macro } from '../../../types';[m
[32m+[m[32mimport { Macro, EditableEl } from '../../../types';[m
 import { MacroSearchOverlay } from './ui/MacroSearchOverlay';[m
 import { createReactRenderer } from '../services/reactRenderer';[m
 import { createFocusManager } from '../services/focusManager';[m
[31m-import { createMacroInserter } from '../services/macroInserter';[m
 import { createStyleInjector } from '../services/styleInjector';[m
 import { SEARCH_OVERLAY_STYLES } from './searchOverlayStyles';[m
[32m+[m[32mimport { getActiveEditable } from '../../detector/editableUtils';[m
 [m
 export function createSearchOverlayManager() {[m
   const renderer = createReactRenderer('macro-search-overlay');[m
   const focusManager = createFocusManager();[m
[31m-  const macroInserter = createMacroInserter(focusManager);[m
   const styleInjector = createStyleInjector('macro-search-overlay-styles', SEARCH_OVERLAY_STYLES);[m
 [m
   let isVisible = false;[m
   let position = { x: 0, y: 0 };[m
 [m
[32m+[m[32m  // Callback for when a macro is selected - should be set by coordinator[m
[32m+[m[32m  let onMacroSelectedCallback: ((macro: Macro, element: EditableEl) => void) | null = null;[m
[32m+[m
   const handleMacroSelection = (macro: Macro): void => {[m
     const targetElement = focusManager.getSavedState()?.element ?? null;[m
[32m+[m
[32m+[m[32m    if (!targetElement) {[m
[32m+[m[32m      focusManager.clear();[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const editableElement = getActiveEditable(targetElement);[m
[32m+[m
[32m+[m[32m    if (!editableElement) {[m
[32m+[m[32m      focusManager.clear();[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m
     focusManager.clear();[m
[31m-    macroInserter.insertMacro(macro, targetElement);[m
[32m+[m
[32m+[m[32m    // If we have a callback registered (from the detector), use it for proper undo tracking[m
[32m+[m[32m    if (onMacroSelectedCallback) {[m
[32m+[m[32m      onMacroSelectedCallback(macro, editableElement);[m
[32m+[m[32m    }[m
 [m
     const event = new CustomEvent('macro-search-selected', {[m
       detail: { macro },[m
[36m@@ -69,6 +88,10 @@[m [mexport function createSearchOverlayManager() {[m
     styleInjector.remove();[m
   };[m
 [m
[32m+[m[32m  const setOnMacroSelected = (callback: (macro: Macro, element: EditableEl) => void) => {[m
[32m+[m[32m    onMacroSelectedCallback = callback;[m
[32m+[m[32m  };[m
[32m+[m
   initialize();[m
 [m
   return {[m
[36m@@ -76,6 +99,7 @@[m [mexport function createSearchOverlayManager() {[m
     hide,[m
     isVisible: getVisibility,[m
     destroy,[m
[32m+[m[32m    setOnMacroSelected,[m
   };[m
 }[m
 [m
[1mdiff --git a/tsconfig.json b/tsconfig.json[m
[1mindex 26c7a3c..cbc2fc5 100644[m
[1m--- a/tsconfig.json[m
[1m+++ b/tsconfig.json[m
[36m@@ -1,7 +1,7 @@[m
 {[m
   "compilerOptions": {[m
     "esModuleInterop": true,[m
[31m-    "lib": ["dom", "es2016"],[m
[32m+[m[32m    "lib": ["dom", "es2021"],[m[41m[m
     "types": ["chrome", "vitest/globals"],[m
     "jsx": "react-jsx"[m
   }[m
